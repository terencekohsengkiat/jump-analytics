<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jump AI - Distance Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    <style>
        body { margin: 0; background: #000; color: white; font-family: sans-serif; overflow: hidden; position: fixed; width: 100%; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; width: 100%; height: 100%; object-fit: cover; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        
        /* Flashing Recording Indicator */
        #rec-dot { position: absolute; top: 20px; left: 20px; color: red; font-weight: bold; font-size: 24px; display: none; align-items: center; gap: 8px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        .pulsing { animation: pulse 1s infinite; }

        #header { background: rgba(0,0,0,0.8); width: 100%; padding: 20px; text-align: center; pointer-events: auto; }
        #status-msg { font-size: 28px; font-weight: 900; color: #00ff00; text-transform: uppercase; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        
        #timer { position: absolute; bottom: 20%; font-size: 150px; font-weight: bold; color: #00ff00; text-shadow: 0 0 20px rgba(0,255,0,0.5); }
        
        .stats-grid { position: absolute; top: 100px; display: grid; grid-template-columns: 1fr; width: 95%; gap: 10px; pointer-events: none; }
        .stat-item { background: rgba(0,0,0,0.6); border-radius: 10px; padding: 15px; display: flex; justify-content: space-between; align-items: center; border: 1px solid #333; }
        .stat-val { font-size: 70px; font-weight: 900; color: #00d2ff; line-height: 1; }
        .stat-label { font-size: 22px; text-transform: uppercase; color: #fff; font-weight: bold; }

        #setup-form { position: absolute; z-index: 100; background: white; color: black; padding: 25px; border-radius: 20px; width: 85%; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        select, input { width: 100%; padding: 15px; margin: 10px 0; border: 2px solid #ddd; border-radius: 10px; font-size: 18px; box-sizing: border-box; }
        #startBtn { width: 100%; padding: 20px; background: #007bff; color: white; border: none; border-radius: 10px; font-weight: bold; font-size: 20px; }
        
        #actionBtnContainer { position: absolute; bottom: 40px; width: 90%; display: flex; gap: 15px; pointer-events: auto; }
        .action-btn { flex: 1; padding: 20px; border-radius: 12px; border: none; font-weight: bold; color: white; font-size: 18px; display: none; }
        #downloadBtn { background: #28a745; }
        #resetBtn { background: #444; }
        
        .calib-line { position: absolute; width: 100%; height: 6px; background: #ff3e3e; display: none; z-index: 10; box-shadow: 0 0 15px red; border-bottom: 2px solid white; }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline style="display:none"></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="setup-form">
        <h2 style="margin:0 0 15px 0">Jump Analysis</h2>
        <select id="jumpType">
            <option value="CMJ">Counter Movement Jump</option>
            <option value="SJ">Squat Jump</option>
            <option value="DJ">Drop Jump</option>
        </select>
        <input type="number" id="heightInput" placeholder="Your Height (cm)" value="180">
        <input type="number" id="weightInput" placeholder="Your Weight (kg)" value="75">
        <button id="startBtn">BEGIN CALIBRATION</button>
    </div>

    <div id="ui-layer">
        <div id="rec-dot" class="pulsing">‚óè REC</div>
        <div id="header"><div id="status-msg">WAITING...</div></div>
        
        <div class="stats-grid">
            <div class="stat-item">
                <span class="stat-label">Height</span>
                <span class="stat-val"><span id="resHeight">0.0</span><small style="font-size:20px">cm</small></span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Velocity</span>
                <span class="stat-val"><span id="resVel">0.0</span><small style="font-size:20px">m/s</small></span>
            </div>
        </div>

        <div id="cal-line-near" class="calib-line" style="top: 15%;"></div>
        <div id="cal-line-far" class="calib-line" style="top: 25%;"></div>
        <div id="timer"></div>

        <div id="actionBtnContainer">
            <button id="downloadBtn" class="action-btn">GET DATA (CSV)</button>
            <button id="resetBtn" class="action-btn">NEW TEST</button>
        </div>
    </div>
</div>

<script type="module">
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusMsg = document.getElementById('status-msg');
    const timerEl = document.getElementById('timer');
    const recDot = document.getElementById('rec-dot');

    let state = 'IDLE', jumpType, userHeight, userWeight;
    let calibrationData = { near: [], far: [] };
    let bioRatio = 0, ppm = 0, floorY = 0, standingHipY = null;
    let jumpLogs = [];
    let isRecording = false, jumpStartTime = 0;
    let maxJumpHeight = 0, maxVelocity = 0;

    function onResults(results) {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // MIRROR EFFECT
        canvasCtx.translate(canvasElement.width, 0);
        canvasCtx.scale(-1, 1);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.poseLandmarks) {
            const l = results.poseLandmarks;
            const noseY = l[0].y; // Nose is safer than eyes for "above head" check
            const ankleY = (l[27].y + l[28].y) / 2;
            const hipY = (l[23].y + l[24].y) / 2;
            // Get highest wrist point (min Y because top is 0)
            const wristY = Math.min(l[15].y, l[16].y); 

            // Skeleton Drawing
            drawConnectors(canvasCtx, l, POSE_CONNECTIONS, {color: '#FFFFFF', lineWidth: 2});
            drawLandmarks(canvasCtx, l, {color: '#00d2ff', lineWidth: 1, radius: 2});
            
            // CoM Dot
            canvasCtx.beginPath();
            canvasCtx.arc(((l[23].x + l[24].x)/2)*canvasElement.width, hipY*canvasElement.height, 12, 0, 2*Math.PI);
            canvasCtx.fillStyle = "yellow";
            canvasCtx.fill();

            // Calibration States
            if (state === 'CAL_NEAR') calibrationData.near.push({eye: noseY, ankle: ankleY});
            if (state === 'CAL_FAR') calibrationData.far.push({eye: noseY, ankle: ankleY});

            // --- FIXED GESTURE LOGIC ---
            // Simply check if wrists are physically higher than the nose.
            // No offsets, just relative position.
            if (state === 'READY_TO_JUMP') {
                if (wristY < noseY && !isRecording) {
                    startJumpCountdown();
                } else if (wristY < noseY && isRecording && (Date.now() - jumpStartTime > 2000)) {
                    stopRecording();
                }
            }

            if (isRecording) {
                processJumpData(hipY, ankleY);
                // Force status update every frame so it doesn't get lost
                if (Date.now() % 1000 < 500) {
                     statusMsg.innerText = "FINISH? HANDS UP!";
                     statusMsg.style.color = "#ff3e3e"; // Red flash
                } else {
                     statusMsg.innerText = "RECORDING...";
                     statusMsg.style.color = "#00ff00"; // Green flash
                }
            }
        }
        canvasCtx.restore();
    }

    function processJumpData(hipY, ankleY) {
        if (!standingHipY) { standingHipY = hipY; floorY = ankleY; }
        const curH = Math.max(0, (standingHipY - hipY) * canvasElement.height / ppm);
        const time = Date.now();

        let vel = 0;
        if (jumpLogs.length > 0) {
            const prev = jumpLogs[jumpLogs.length-1];
            vel = (curH - prev.h) / ((time - prev.t) / 1000);
        }

        if (curH * 100 > maxJumpHeight) maxJumpHeight = curH * 100;
        if (vel > maxVelocity) maxVelocity = vel;

        document.getElementById('resHeight').innerText = maxJumpHeight.toFixed(1);
        document.getElementById('resVel').innerText = Math.max(0, maxVelocity).toFixed(2);
        jumpLogs.push({t: time, h: curH, v: vel});
    }

    async function startJumpCountdown() {
        state = 'COUNTDOWN';
        await waitWithTimer("GET READY...", 3);
        isRecording = true;
        recDot.style.display = 'flex';
        jumpStartTime = Date.now();
        state = 'READY_TO_JUMP'; // Back to this state so we can detect the "Stop" gesture
    }

    function stopRecording() {
        isRecording = false;
        recDot.style.display = 'none';
        statusMsg.innerText = "TEST COMPLETE";
        statusMsg.style.color = "#00ff00";
        document.getElementById('downloadBtn').style.display = 'block';
        document.getElementById('resetBtn').style.display = 'block';
    }

    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5 });
    pose.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await pose.send({image: videoElement}); },
        width: 1280, height: 720
    });

    document.getElementById('startBtn').addEventListener('click', () => {
        jumpType = document.getElementById('jumpType').value;
        userHeight = parseFloat(document.getElementById('heightInput').value);
        userWeight = parseFloat(document.getElementById('weightInput').value);
        document.getElementById('setup-form').style.display = 'none';
        camera.start();
        runCalibration();
    });

    async function runCalibration() {
        state = 'CAL_NEAR';
        document.getElementById('cal-line-near').style.display = 'block';
        await waitWithTimer("STAY STILL: TOP LINE", 10);
        document.getElementById('cal-line-near').style.display = 'none';

        state = 'CAL_FAR';
        document.getElementById('cal-line-far').style.display = 'block';
        await waitWithTimer("STAY STILL: LOWER LINE", 10);
        document.getElementById('cal-line-far').style.display = 'none';

        const calc = (data, lineY) => {
            const avgE = data.reduce((a,b) => a+b.eye,0)/data.length;
            const avgA = data.reduce((a,b) => a+b.ankle,0)/data.length;
            return { ppm: Math.abs(lineY - avgA) * canvasElement.height / (userHeight/100) };
        };
        const r1 = calc(calibrationData.near, 0.15);
        const r2 = calc(calibrationData.far, 0.25);
        ppm = (r1.ppm + r2.ppm) / 2;

        state = 'READY_TO_JUMP';
        statusMsg.innerText = "RAISE HANDS TO START";
    }

    function waitWithTimer(msg, sec) {
        return new Promise(res => {
            let c = sec;
            const i = setInterval(() => {
                statusMsg.innerText = msg;
                timerEl.innerText = c--;
                if (c < 0) { clearInterval(i); timerEl.innerText = ""; res(); }
            }, 1000);
        });
    }

    document.getElementById('resetBtn').addEventListener('click', () => location.reload());
    document.getElementById('downloadBtn').addEventListener('click', () => {
        let csv = `Jump: ${jumpType}, H: ${userHeight}cm, W: ${userWeight}kg\nTime(ms),Height(m),Vel(m/s)\n`;
        jumpLogs.forEach(r => { csv += `${r.t},${r.h.toFixed(4)},${r.v.toFixed(4)}\n`; });
        const blob = new Blob([csv], { type: 'text/csv' });
        const a = document.createElement('a');
        a.href = window.URL.createObjectURL(blob);
        a.download = `jump_${jumpType}.csv`; a.click();
    });
</script>
</body>
</html>
