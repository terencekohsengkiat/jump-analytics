<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Jump AI - Final Logic Fix</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
    <style>
        body { margin: 0; background: #000; color: white; font-family: sans-serif; overflow: hidden; position: fixed; width: 100%; }
        #container { position: relative; width: 100vw; height: 100vh; }
        video, canvas { position: absolute; width: 100%; height: 100%; object-fit: cover; }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; pointer-events: none; }
        
        #manual-stop-btn { 
            position: absolute; top: 15px; right: 15px; 
            background: rgba(220, 53, 69, 0.9); color: white; 
            padding: 15px 30px; border-radius: 30px; font-weight: bold; 
            pointer-events: auto; display: none; border: 2px solid white; font-size: 18px; z-index: 999;
        }

        #rec-dot { position: absolute; top: 20px; left: 20px; color: red; font-weight: bold; font-size: 24px; display: none; align-items: center; gap: 8px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; }
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }
        .pulsing { animation: pulse 1s infinite; }

        #header { background: rgba(0,0,0,0.6); width: 100%; padding: 60px 20px 20px 20px; text-align: center; pointer-events: auto; }
        #status-msg { font-size: 28px; font-weight: 900; color: #00ff00; text-transform: uppercase; text-shadow: 0 2px 4px rgba(0,0,0,0.8); }
        
        #timer { position: absolute; bottom: 20%; font-size: 150px; font-weight: bold; color: #00ff00; text-shadow: 0 0 20px rgba(0,255,0,0.5); }
        
        .stats-grid { position: absolute; top: 140px; display: grid; grid-template-columns: 1fr; width: 95%; gap: 10px; pointer-events: none; }
        .stat-item { background: rgba(0,0,0,0.6); border-radius: 10px; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; border: 1px solid #555; }
        .stat-val { font-size: 60px; font-weight: 900; color: #00d2ff; line-height: 1; }
        .stat-label { font-size: 20px; text-transform: uppercase; color: #fff; font-weight: bold; }

        #setup-form { position: absolute; z-index: 100; background: white; color: black; padding: 25px; border-radius: 20px; width: 85%; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: auto; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        select, input { width: 100%; padding: 15px; margin: 10px 0; border: 2px solid #ddd; border-radius: 10px; font-size: 18px; box-sizing: border-box; }
        #startBtn { width: 100%; padding: 20px; background: #007bff; color: white; border: none; border-radius: 10px; font-weight: bold; font-size: 20px; }
        
        #actionBtnContainer { position: absolute; bottom: 40px; width: 90%; display: flex; gap: 15px; pointer-events: auto; }
        .action-btn { flex: 1; padding: 20px; border-radius: 12px; border: none; font-weight: bold; color: white; font-size: 18px; display: none; }
        #downloadBtn { background: #28a745; }
        #resetBtn { background: #444; }
        
        .calib-line { position: absolute; width: 100%; height: 6px; background: #ff3e3e; display: none; z-index: 10; box-shadow: 0 0 15px red; border-bottom: 2px solid white; }
    </style>
</head>
<body>

<div id="container">
    <video id="input_video" playsinline style="display:none"></video>
    <canvas id="output_canvas"></canvas>
    
    <div id="setup-form">
        <h2 style="margin:0 0 15px 0">Jump Analysis</h2>
        <p style="font-size:14px; color: #666; margin-bottom: 15px;">1. Calibrate (Stand Still)<br>2. Walk Away (Any Distance)<br>3. Raise Hands to Lock & Jump</p>
        <select id="jumpType">
            <option value="CMJ">Counter Movement Jump</option>
            <option value="SJ">Squat Jump</option>
            <option value="DJ">Drop Jump</option>
        </select>
        <input type="number" id="heightInput" placeholder="Your Height (cm)" value="180">
        <input type="number" id="weightInput" placeholder="Your Weight (kg)" value="75">
        <button id="startBtn">START CAMERA</button>
    </div>

    <div id="ui-layer">
        <button id="manual-stop-btn">TAP TO STOP</button>
        <div id="rec-dot" class="pulsing">‚óè REC</div>
        <div id="header"><div id="status-msg">WAITING...</div></div>
        
        <div class="stats-grid">
            <div class="stat-item">
                <span class="stat-label">Height</span>
                <span class="stat-val"><span id="resHeight">0.0</span><small style="font-size:20px">cm</small></span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Velocity</span>
                <span class="stat-val"><span id="resVel">0.0</span><small style="font-size:20px">m/s</small></span>
            </div>
        </div>

        <div id="cal-line-near" class="calib-line" style="top: 12%;"></div>
        <div id="cal-line-far" class="calib-line" style="top: 20%;"></div>
        <div id="timer"></div>

        <div id="actionBtnContainer">
            <button id="downloadBtn" class="action-btn">GET DATA (CSV)</button>
            <button id="resetBtn" class="action-btn">NEW TEST</button>
        </div>
    </div>
</div>

<script type="module">
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusMsg = document.getElementById('status-msg');
    const timerEl = document.getElementById('timer');
    const recDot = document.getElementById('rec-dot');
    const stopBtn = document.getElementById('manual-stop-btn');

    let state = 'IDLE', jumpType, userHeight, userWeight;
    let calibrationData = { near: [], far: [] };
    let bioRatio = 0, livePPM = 0, lockedPPM = 0;
    let floorY = 0, standingHipY = null;
    let jumpLogs = [];
    let isRecording = false, jumpStartTime = 0;
    let maxJumpHeight = 0, maxVelocity = 0;

    function onResults(results) {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        canvasCtx.translate(canvasElement.width, 0);
        canvasCtx.scale(-1, 1);
        canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

        if (results.poseLandmarks) {
            const l = results.poseLandmarks;
            const noseY = l[0].y;
            const shoulderY = (l[11].y + l[12].y) / 2;
            const ankleY = (l[27].y + l[28].y) / 2;
            const hipY = (l[23].y + l[24].y) / 2;
            const wristY = Math.min(l[15].y, l[16].y); 

            drawConnectors(canvasCtx, l, POSE_CONNECTIONS, {color: '#FFFFFF', lineWidth: 2});
            drawLandmarks(canvasCtx, l, {color: '#00d2ff', lineWidth: 1, radius: 2});
            canvasCtx.beginPath();
            canvasCtx.arc(((l[23].x + l[24].x)/2)*canvasElement.width, hipY*canvasElement.height, 12, 0, 2*Math.PI);
            canvasCtx.fillStyle = "yellow";
            canvasCtx.fill();

            // 1. DYNAMIC RULER
            if (bioRatio > 0) {
                 const currentAnkleToEye = Math.abs(ankleY - noseY);
                 const totalBodyPixels = currentAnkleToEye * (1 + bioRatio);
                 livePPM = totalBodyPixels * canvasElement.height / (userHeight / 100);
            }

            // Calibration Phase
            if (state === 'CAL_NEAR') calibrationData.near.push({eye: noseY, ankle: ankleY});
            if (state === 'CAL_FAR') calibrationData.far.push({eye: noseY, ankle: ankleY});

            // --- 2. GESTURE LOGIC ---
            const handsUp = wristY < shoulderY; // Simple check

            // ONLY check for start if we are in the correct state
            if (state === 'READY_TO_JUMP') {
                if (handsUp && !isRecording) {
                    if (livePPM > 0) {
                        lockedPPM = livePPM; 
                        startJumpCountdown();
                    }
                } 
                // Only allow STOP if recording has been running for at least 0.5s
                else if (handsUp && isRecording && (Date.now() - jumpStartTime > 500)) {
                    stopRecording();
                }
            }
            // Note: If state is 'FINISHED', we ignore all gestures.

            if (isRecording) {
                processJumpData(hipY, ankleY);
                if (Date.now() % 1000 < 500) {
                     statusMsg.innerText = "FINISH? HANDS UP!";
                     statusMsg.style.color = "#ff3e3e"; 
                } else {
                     statusMsg.innerText = "RECORDING...";
                     statusMsg.style.color = "#00ff00"; 
                }
            }
        }
        canvasCtx.restore();
    }

    function processJumpData(hipY, ankleY) {
        if (!standingHipY) { standingHipY = hipY; floorY = ankleY; }
        const curH = Math.max(0, (standingHipY - hipY) * canvasElement.height / lockedPPM);
        const time = Date.now();
        let vel = 0;
        if (jumpLogs.length > 0) {
            const prev = jumpLogs[jumpLogs.length-1];
            vel = (curH - prev.h) / ((time - prev.t) / 1000);
        }
        if (curH * 100 > maxJumpHeight) maxJumpHeight = curH * 100;
        if (vel > maxVelocity) maxVelocity = vel;

        document.getElementById('resHeight').innerText = maxJumpHeight.toFixed(1);
        document.getElementById('resVel').innerText = Math.max(0, maxVelocity).toFixed(2);
        jumpLogs.push({t: time, h: curH, v: vel});
    }

    async function startJumpCountdown() {
        state = 'COUNTDOWN'; // Change state so we don't double-trigger
        await waitWithTimer("LOCKING SCALE...", 3);
        
        // Reset Jump Data for new test
        maxJumpHeight = 0;
        maxVelocity = 0;
        jumpLogs = [];
        standingHipY = null;
        
        isRecording = true;
        recDot.style.display = 'flex';
        stopBtn.style.display = 'block';
        jumpStartTime = Date.now();
        state = 'READY_TO_JUMP'; 
    }

    function stopRecording() {
        if (!isRecording) return;
        isRecording = false;
        
        // --- CRITICAL FIX: CHANGE STATE TO 'FINISHED' ---
        state = 'FINISHED'; 
        
        recDot.style.display = 'none';
        stopBtn.style.display = 'none';
        statusMsg.innerText = "TEST COMPLETE";
        statusMsg.style.color = "#00ff00";
        document.getElementById('downloadBtn').style.display = 'block';
        document.getElementById('resetBtn').style.display = 'block';
    }

    function resetTest() {
        // Reset UI but keep calibration
        document.getElementById('downloadBtn').style.display = 'none';
        document.getElementById('resetBtn').style.display = 'none';
        document.getElementById('resHeight').innerText = "0.0";
        document.getElementById('resVel').innerText = "0.0";
        statusMsg.innerText = "STAND ANYWHERE -> HANDS UP";
        state = 'READY_TO_JUMP'; // Re-enable gesture detection
    }

    stopBtn.addEventListener('click', stopRecording);
    document.getElementById('resetBtn').addEventListener('click', resetTest);

    const pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
    pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.5 });
    pose.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => { await pose.send({image: videoElement}); },
        width: 1280, height: 720
    });

    document.getElementById('startBtn').addEventListener('click', () => {
        jumpType = document.getElementById('jumpType').value;
        userHeight = parseFloat(document.getElementById('heightInput').value);
        userWeight = parseFloat(document.getElementById('weightInput').value);
        document.getElementById('setup-form').style.display = 'none';
        camera.start();
        runCalibration();
    });

    async function runCalibration() {
        state = 'CAL_NEAR';
        document.getElementById('cal-line-near').style.display = 'block';
        await waitWithTimer("STAY STILL: TOP LINE", 10);
        document.getElementById('cal-line-near').style.display = 'none';

        state = 'CAL_FAR';
        document.getElementById('cal-line-far').style.display = 'block';
        await waitWithTimer("STAY STILL: LOWER LINE", 10);
        document.getElementById('cal-line-far').style.display = 'none';

        const calcBio = (data, lineY) => {
            const avgEye = data.reduce((a,b) => a+b.eye,0)/data.length;
            const avgAnkle = data.reduce((a,b) => a+b.ankle,0)/data.length;
            const eyeToCrown = Math.abs(lineY - avgEye);
            const ankleToEye = Math.abs(avgAnkle - avgEye);
            return eyeToCrown / ankleToEye;
        };

        const r1 = calcBio(calibrationData.near, 0.12);
        const r2 = calcBio(calibrationData.far, 0.20);
        bioRatio = (r1 + r2) / 2;

        state = 'READY_TO_JUMP';
        statusMsg.innerText = "STAND ANYWHERE -> HANDS UP";
    }

    function waitWithTimer(msg, sec) {
        return new Promise(res => {
            let c = sec;
            const i = setInterval(() => {
                statusMsg.innerText = msg;
                timerEl.innerText = c--;
                if (c < 0) { clearInterval(i); timerEl.innerText = ""; res(); }
            }, 1000);
        });
    }

    document.getElementById('downloadBtn').addEventListener('click', () => {
        let csv = `Jump: ${jumpType}, H: ${userHeight}cm, W: ${userWeight}kg\nTime(ms),Height(m),Vel(m/s)\n`;
        jumpLogs.forEach(r => { csv += `${r.t},${r.h.toFixed(4)},${r.v.toFixed(4)}\n`; });
        const blob = new Blob([csv], { type: 'text/csv' });
        const a = document.createElement('a');
        a.href = window.URL.createObjectURL(blob);
        a.download = `jump_${jumpType}.csv`; a.click();
    });
</script>
</body>
</html>
